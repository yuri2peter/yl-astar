{"version":3,"sources":["../src/index.js"],"names":["Node","id","parentId","updateCosts","forNowCost","predictCost","costs","Astar","startNodeId","endNodeId","getNeighbors","startNode","endNode","data","openList","openSet","Set","closeSet","nodes","lastNode","add","push","has","size","currentNode","shift","neighborNodes","forEach","singleCost","newNode","testNode","newForNowCost","setParentId","_","pullAllBy","sortedIndex","sortedIndexBy","t","getCosts","splice","path","currentPathNode","unshift"],"mappings":"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","sourcesContent":["import _ from 'lodash';\n\nclass Node {\n  constructor(id) {\n    this.id = id;\n    this.parentId = null;\n    this.updateCosts(0, 0);\n  }\n\n  setParentId(parentId) {\n    this.parentId = parentId;\n  }\n\n  updateCosts(forNowCost, predictCost) {\n    this.forNowCost = forNowCost; // g\n    this.predictCost = predictCost; // h\n    this.costs = this.forNowCost + this.predictCost; // f\n  }\n\n  getCosts() {\n    return this.costs;\n  }\n}\n\nclass Astar {\n  /**\n   * Set start and end nodes\n   * @param {string} startNodeId\n   * @param {string} endNodeId\n   * @param {function} getNeighbors\n   *   async (nodeId) => [{id: id1, singleCost: g1, predictCost: h1}, {id: id2, singleCost: g2, predictCost: h2}]\n   */\n  constructor(startNodeId, endNodeId, getNeighbors) {\n    const startNode = new Node(startNodeId);\n    const endNode = new Node(endNodeId);\n    this.data = {\n      openList: [],\n      openSet: new Set(),\n      closeSet: new Set(),\n      nodes: {},\n      startNode,\n      endNode,\n      lastNode: null,\n    };\n    this.getNeighbors = getNeighbors;\n    this.data.nodes[startNodeId] = startNode;\n    this.data.nodes[endNodeId] = endNode;\n    this.data.openSet.add(startNodeId);\n    this.data.openSet.add(startNodeId);\n    this.data.openList.push(startNode);\n  }\n\n  /**\n   * 下一步\n   * @return {Promise<number>} 0 未完成, 1 完成, -1 找不到路径\n   */\n  async next() {\n    // 把终点加入到了 open list 中，此时路径已经找到\n    if (this.data.openSet.has(this.data.endNode.id)) {\n      return 1;\n    }\n\n    // open list 是空的，此时没有路径\n    if (this.data.openSet.size === 0) {\n      return -1;\n    }\n\n    const currentNode = this.data.openList.shift(); // Node which has min f\n    this.data.closeSet.add(currentNode.id); // Add to closeSet\n\n    const neighborNodes = await this.getNeighbors(currentNode.id);\n    neighborNodes.forEach(({ id, singleCost, predictCost }) => {\n      if (this.data.closeSet.has(id) ) { return; }\n      if (!this.data.nodes[id]) {\n        const newNode = new Node(id);\n        newNode.updateCosts(singleCost, predictCost);\n        this.data.nodes[id] = newNode;\n      }\n      const testNode = this.data.nodes[id];\n      if (this.data.openSet.has(id)) {\n        // 如果它已经在 open list 中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更好，用 G 值作参考。\n        // 更小的 G 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。\n        // 如果你的 open list 是按 F 值排序的话，改变后你可能需要重新排序。\n        const newForNowCost = singleCost + currentNode.forNowCost;\n        if (newForNowCost < testNode.forNowCost) {\n          // 更新节点信息\n          testNode.setParentId(currentNode.id);\n          testNode.updateCosts(newForNowCost, predictCost);\n\n          // 重新排序\n          _.pullAllBy(this.data.openList, [testNode], 'id');\n          const sortedIndex = _.sortedIndexBy(this.data.openList, testNode, t => t.getCosts());\n          this.data.openList.splice(sortedIndex, 0, testNode);\n        }\n      } else {\n        // 如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值\n        const newForNowCost = singleCost + currentNode.forNowCost;\n        testNode.updateCosts(newForNowCost, predictCost);\n\n        this.data.openSet.add(id);\n        testNode.setParentId(currentNode.id);\n        const sortedIndex = _.sortedIndexBy(this.data.openList, testNode, t => t.getCosts());\n        this.data.openList.splice(sortedIndex, 0, testNode);\n      }\n    });\n    this.data.lastNode = currentNode;\n    return 0;\n  }\n\n  getPath () {\n    const path = [];\n    let currentPathNode = this.data.lastNode;\n    while (currentPathNode.parentId) {\n      path.unshift(currentPathNode.id);\n      currentPathNode = this.data.nodes[currentPathNode.parentId];\n    }\n    return path;\n  }\n\n}\n\nexport default Astar;\n"],"file":"index.js"}